Промт для Replit
(одним куском, без уточняющих вопросов)

⸻

“Сохраняет, но будто бы нет” — чин-им дифф-детект и запрос на сервер

0  Суть бага из логов
	•	Form change detected, real changes: **false** — сравнение «что есть» и «что было» всегда даёт false, поэтому хук считает, что сохранять нечего и PATCH не уходит.
	•	Причина — сравниваются два свежесгенерированных объекта (новая ссылка), но поля внутри совпадают по значению, потому что:
	•	planData и calendarData уже подтянуты из API и перезаписали локальный initialRef;
	•	сравнение идёт поверхностным способом (=== / ссылкой).

1  Что делаем
	1.	Глубокий контрольный хэш
	•	В useAutoSave добавь:

const jsonHash = (v:any)=>stableStringify(v);   // npm i fast-json-stable-stringify


	•	Храним две строки-хэша:

const [lastSavedHash, setLastSavedHash] = useState(jsonHash(data));


	•	hasChanges = jsonHash(data) !== lastSavedHash;

	2.	Обновляем «эталон» только после 2-х вещей
	•	PATCH/PUT ⇢ 200/204.
	•	Смены вкладки (мы уже делаем pause, так что просто в resume()).

const afterSuccessfulSave = ()=> {
  setLastSavedHash(jsonHash(data));
  setPaused(false);    // если был ручной save
};


	3.	Отдельно сравниваем большие куски
(чтобы не гонять лишний stringify, но логи всё же нужны)

if (calendarDirty || planDirty || formDirty) hasChanges = true;

где

const calendarDirty = jsonHash(calendarState)!==lastSaved.calendar;
const planDirty     = jsonHash(planState)!==lastSaved.plan;
const formDirty     = jsonHash(formState)!==lastSaved.form;


	4.	Отправляем единый PATCH
*В api.updateCurriculumPlan добавь *:

export interface CurriculumPayload {
  ...,
  calendarJson: string,   // stringify({})
  planJson:      string,   // stringify([])
}

и в saveCurriculum():

await api.updateCurriculumPlan(id,{
  ...formState,
  calendarJson: JSON.stringify(calendarState),
  planJson:     JSON.stringify(planState),
});
afterSuccessfulSave();


	5.	Убираем лишние логи
Когда process.env.NODE_ENV==='production' — блокируем console.log в этих файлах, иначе смесь рейтового вывода мешает.

2  Проверка
	1.	Меняем форму обучения → «Сохранить изменения» → сеть: один PATCH, в ответе 200.
	2.	F5 — выпадашка остаётся «Заочная» (или что выбрано).
	3.	Добавляем часы в ячейке плана → 1 PATCH.
	4.	Выключаем автосейв (pause) → меняем три ячейки → ручное «Сохранить» → один PATCH.
	5.	Switch to «График» и обратно — hasChanges = false (ничего не шлём).

3  Чем пользуемся
	•	fast-json-stable-stringify для «канонического» JSON без reorder полей.
	•	Текущий hook pause / resume — оставляем, просто переносим контроль хэша внутрь.

⸻

Ожидаемый результат
Любое фактическое изменение (форма, годы, календарь, учебный план) попадает в один PATCH. После успешного ответа страница показывает сохранённые данные даже после перезагрузки, а консоль перестаёт спамить.